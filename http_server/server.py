"""FastAPI HTTP server for graph-code.

Auto-generated on 2025-12-11T16:22:29.154434+00:00
Do not edit this file manually - regenerate using the bootstrap command.
"""

import asyncio
import json
import os
import signal
import time
import uuid
from collections.abc import AsyncGenerator, Awaitable, Callable
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any, Optional

from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from jsonschema import Draft7Validator, ValidationError as JSONSchemaValidationError
from loguru import logger

from codebase_rag.mcp.tools import MCPToolsRegistry, create_mcptools_registry
from http_server.models import (
    CallToolRequest,
    ErrorCode,
    ResponseEnvelope,
    ServiceInfo,
    ToolSchema,
)

_server_start_time: Optional[float] = None
_shutdown_requested = False
_mcp_tools_registry: Optional[MCPToolsRegistry] = None
_server_initialized = False


def get_uptime_seconds() -> int:
    """Get server uptime in seconds."""
    global _server_start_time
    if _server_start_time is None:
        return 0
    return int(time.time() - _server_start_time)


def get_tools_registry() -> MCPToolsRegistry:
    """Get the global MCP tools registry."""
    global _mcp_tools_registry, _server_initialized
    if not _server_initialized or _mcp_tools_registry is None:
        raise RuntimeError("Server not initialized - MCP tools registry not available")
    return _mcp_tools_registry


def is_server_initialized() -> bool:
    """Check if the server has completed initialization."""
    global _server_initialized
    return _server_initialized


def discover_tools() -> ServiceInfo:
    """Discover all available MCP tools and their schemas."""
    registry = get_tools_registry()
    mcp_schemas = registry.get_tool_schemas()

    tools = [
        ToolSchema(
            name=schema["name"],
            description=schema["description"],
            input_schema=schema["inputSchema"],
        )
        for schema in mcp_schemas
    ]

    return ServiceInfo(
        service="graph-code",
        version="0.0.24",
        tools=tools,
    )


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """FastAPI lifespan context manager for startup/shutdown."""
    global _server_start_time, _shutdown_requested, _mcp_tools_registry, _server_initialized

    _server_start_time = time.time()
    _shutdown_requested = False
    _server_initialized = False

    logger.info(f"Starting {app.title} v{app.version}")
    logger.info(f"Listening on 127.0.0.1:9001")

    try:
        logger.info("Initializing MCP tools registry...")

        project_root = os.environ.get("TARGET_REPO_PATH") or str(Path.cwd())
        logger.info(f"Project root: {project_root}")

        _mcp_tools_registry = create_mcptools_registry(
            project_root=project_root
        )

        _server_initialized = True
        tool_names = _mcp_tools_registry.list_tool_names()
        logger.info(f"MCP tools registry initialized with {len(tool_names)} tools")
        logger.debug(f"Available tools: {', '.join(tool_names)}")

    except Exception as e:
        logger.error(f"Failed to initialize MCP tools registry: {e}", exc_info=True)
        _server_initialized = False

    yield

    logger.info("Initiating graceful shutdown...")
    _shutdown_requested = True

    if _mcp_tools_registry is not None:
        logger.info("Cleaning up MCP tools registry...")
        _mcp_tools_registry = None

    logger.info("Shutdown complete")


def create_app() -> FastAPI:
    """Create and configure FastAPI application."""
    app = FastAPI(
        title="graph-code HTTP Server",
        description="HTTP wrapper for MCP tools",
        version="0.0.24",
        lifespan=lifespan,
    )

    def signal_handler(signum: int, frame: Any) -> None:
        logger.info(f"Received signal {signum}, initiating shutdown...")

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    @app.middleware("http")
    async def request_id_middleware(
        request: Request, call_next: Callable[[Request], Awaitable[Response]]
    ) -> Response:
        """Generate or extract request_id from headers."""
        request_id = request.headers.get("x-request-id") or str(uuid.uuid4())
        request.state.request_id = request_id
        response = await call_next(request)
        response.headers["x-request-id"] = request_id
        return response

    @app.middleware("http")
    async def logging_middleware(
        request: Request, call_next: Callable[[Request], Awaitable[Response]]
    ) -> Response:
        """Log all requests and responses with request_id correlation."""
        request_id = getattr(request.state, "request_id", "unknown")
        start_time = time.time()

        logger.info(
            f"Request started | request_id={request_id} | method={request.method} | path={request.url.path}"
        )

        try:
            response = await call_next(request)
            duration_ms = int((time.time() - start_time) * 1000)

            logger.info(
                f"Request completed | request_id={request_id} | status={response.status_code} | duration_ms={duration_ms}"
            )

            return response
        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            logger.error(
                f"Request failed | request_id={request_id} | error={str(e)} | duration_ms={duration_ms}"
            )
            raise

    @app.exception_handler(Exception)
    async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
        """Convert all exceptions to ResponseEnvelope format."""
        request_id = getattr(request.state, "request_id", str(uuid.uuid4()))

        if isinstance(exc, ValueError):
            error_code = ErrorCode.INVALID_ARGUMENTS
            status_code = 400
        elif isinstance(exc, FileNotFoundError):
            error_code = ErrorCode.TOOL_NOT_FOUND
            status_code = 404
        elif isinstance(exc, TimeoutError):
            error_code = ErrorCode.TIMEOUT
            status_code = 504
        else:
            error_code = ErrorCode.INTERNAL_ERROR
            status_code = 500

        envelope = ResponseEnvelope[None](
            success=False,
            error=str(exc),
            code=error_code,
            request_id=request_id,
        )

        logger.error(
            f"Exception in request | request_id={request_id} | error_code={error_code} | error={str(exc)}"
        )

        return JSONResponse(
            status_code=status_code,
            content=envelope.model_dump(mode="json", exclude_none=True),
        )

    @app.get("/")
    async def root() -> dict[str, str]:
        """Root endpoint."""
        return {
            "service": "graph-code",
            "version": "0.0.24",
            "status": "operational",
        }

    @app.get("/tools", response_model=ServiceInfo, tags=["discovery"])
    async def list_tools(request: Request) -> ServiceInfo | JSONResponse:
        """List all available MCP tools with their schemas."""
        if not is_server_initialized():
            request_id = getattr(request.state, "request_id", str(uuid.uuid4()))

            envelope = ResponseEnvelope[None](
                success=False,
                error="Service is initializing, please retry in a few seconds",
                code=ErrorCode.SERVICE_UNAVAILABLE,
                request_id=request_id,
            )

            return JSONResponse(
                status_code=503,
                content=envelope.model_dump(mode="json", exclude_none=True),
                headers={"Retry-After": "5"},
            )

        try:
            service_info = discover_tools()
            return service_info
        except Exception as e:
            request_id = getattr(request.state, "request_id", str(uuid.uuid4()))
            logger.error(
                f"Error discovering tools | request_id={request_id} | error={str(e)}"
            )

            envelope = ResponseEnvelope[None](
                success=False,
                error=f"Failed to discover tools: {str(e)}",
                code=ErrorCode.INTERNAL_ERROR,
                request_id=request_id,
            )

            return JSONResponse(
                status_code=500,
                content=envelope.model_dump(mode="json", exclude_none=True),
            )

    @app.post("/call-tool", tags=["tools"])
    async def call_tool(tool_request: CallToolRequest, request: Request) -> JSONResponse:
        """Execute an MCP tool with the provided arguments."""
        request_id: str = str(
            tool_request.request_id
            or getattr(request.state, "request_id", str(uuid.uuid4()))
        )

        if not is_server_initialized():
            envelope = ResponseEnvelope[None](
                success=False,
                error="Service is initializing, please retry in a few seconds",
                code=ErrorCode.SERVICE_UNAVAILABLE,
                request_id=request_id,
            )
            return JSONResponse(
                status_code=503,
                content=envelope.model_dump(mode="json", exclude_none=True),
                headers={"Retry-After": "5"},
            )

        try:
            registry = get_tools_registry()

            handler_info = registry.get_tool_handler(tool_request.tool)
            if handler_info is None:
                envelope = ResponseEnvelope[None](
                    success=False,
                    error=f"Tool not found: {tool_request.tool}",
                    code=ErrorCode.TOOL_NOT_FOUND,
                    request_id=request_id,
                )
                return JSONResponse(
                    status_code=404,
                    content=envelope.model_dump(mode="json", exclude_none=True),
                )

            handler, returns_json = handler_info

            tool_schemas = registry.get_tool_schemas()
            tool_schema = next(
                (s for s in tool_schemas if s["name"] == tool_request.tool),
                None
            )

            if tool_schema is None:
                envelope = ResponseEnvelope[None](
                    success=False,
                    error=f"Tool schema not found: {tool_request.tool}",
                    code=ErrorCode.INTERNAL_ERROR,
                    request_id=request_id,
                )
                return JSONResponse(
                    status_code=500,
                    content=envelope.model_dump(mode="json", exclude_none=True),
                )

            try:
                validator = Draft7Validator(tool_schema["inputSchema"])
                validator.validate(tool_request.arguments)
            except JSONSchemaValidationError as e:
                error_path = ".".join(str(p) for p in e.path) if e.path else "root"
                error_msg = f"Invalid argument at {error_path}: {e.message}"

                envelope = ResponseEnvelope[None](
                    success=False,
                    error=error_msg,
                    code=ErrorCode.INVALID_ARGUMENTS,
                    request_id=request_id,
                )
                return JSONResponse(
                    status_code=400,
                    content=envelope.model_dump(mode="json", exclude_none=True),
                )

            start_time = time.time()
            timeout_seconds = 30

            try:
                result = await asyncio.wait_for(
                    handler(**tool_request.arguments),
                    timeout=timeout_seconds
                )

                execution_time_ms = int((time.time() - start_time) * 1000)

                if returns_json:
                    if isinstance(result, dict):
                        result_data = result
                    else:
                        try:
                            result_data = json.loads(str(result))
                        except json.JSONDecodeError:
                            result_data = {"result": str(result)}
                else:
                    result_data = {"result": str(result)}

                success_envelope = ResponseEnvelope[dict[str, Any]](
                    success=True,
                    data=result_data,
                    request_id=request_id,
                    meta={"execution_time_ms": execution_time_ms}
                )

                return JSONResponse(
                    status_code=200,
                    content=success_envelope.model_dump(mode="json", exclude_none=True),
                )

            except asyncio.TimeoutError:
                execution_time_ms = int((time.time() - start_time) * 1000)

                envelope = ResponseEnvelope[None](
                    success=False,
                    error=f"Tool execution exceeded timeout of {timeout_seconds} seconds",
                    code=ErrorCode.TIMEOUT,
                    request_id=request_id,
                    meta={"execution_time_ms": execution_time_ms}
                )

                logger.warning(
                    f"Tool execution timeout | tool={tool_request.tool} | "
                    f"timeout={timeout_seconds}s | request_id={request_id}"
                )

                return JSONResponse(
                    status_code=408,
                    content=envelope.model_dump(mode="json", exclude_none=True),
                )

        except Exception as e:
            execution_time_ms = int((time.time() - start_time) * 1000) if 'start_time' in locals() else 0

            logger.error(
                f"Tool execution error | tool={tool_request.tool} | "
                f"error={str(e)} | request_id={request_id}",
                exc_info=True
            )

            envelope = ResponseEnvelope[None](
                success=False,
                error=f"Tool execution error: {str(e)}",
                code=ErrorCode.EXECUTION_ERROR,
                request_id=request_id,
                meta={"execution_time_ms": execution_time_ms} if execution_time_ms > 0 else None
            )

            return JSONResponse(
                status_code=500,
                content=envelope.model_dump(mode="json", exclude_none=True),
            )

    @app.get("/health", tags=["health"])
    async def health() -> dict[str, Any]:
        """Check service health."""
        return {
            "status": "healthy" if is_server_initialized() else "initializing",
            "service": "graph-code",
            "version": "0.0.24",
            "uptime_seconds": get_uptime_seconds(),
        }

    return app


app = create_app()